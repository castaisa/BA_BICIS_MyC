import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import (
    mean_absolute_error, 
    mean_squared_error, 
    r2_score,
    mean_absolute_percentage_error,
    explained_variance_score
)
from typing import Dict, Optional, Tuple, Union
import warnings


def calcular_metricas_regresion(y_true, y_pred):
    """
    Calcula todas las mÃ©tricas de regresiÃ³n para un modelo.
    
    Args:
        y_true: Valores reales
        y_pred: Valores predichos
    
    Returns:
        dict: Diccionario con todas las mÃ©tricas
    """
    
    # Convertir a numpy arrays
    y_true = np.array(y_true)
    y_pred = np.array(y_pred)
    
    # MÃ©tricas bÃ¡sicas
    mae = mean_absolute_error(y_true, y_pred)
    mse = mean_squared_error(y_true, y_pred)
    rmse = np.sqrt(mse)
    r2 = r2_score(y_true, y_pred)
    
    # MÃ©tricas adicionales
    try:
        mape = mean_absolute_percentage_error(y_true, y_pred) * 100
    except:
        # Calcular MAPE manualmente si sklearn no lo tiene
        mask = y_true != 0
        mape = np.mean(np.abs((y_true[mask] - y_pred[mask]) / y_true[mask])) * 100 if np.any(mask) else np.inf
    
    explained_var = explained_variance_score(y_true, y_pred)
    max_error = np.max(np.abs(y_true - y_pred))
    
    # MÃ©tricas estadÃ­sticas
    mean_true = np.mean(y_true)
    mean_pred = np.mean(y_pred)
    std_true = np.std(y_true)
    std_pred = np.std(y_pred)
    
    # CorrelaciÃ³n
    correlation = np.corrcoef(y_true, y_pred)[0, 1] if len(y_true) > 1 else np.nan
    
    # Sesgo (bias)
    bias = np.mean(y_pred - y_true)
    
    # Error relativo medio
    relative_error = np.mean(np.abs(y_true - y_pred) / np.maximum(np.abs(y_true), 1e-8)) * 100
    
    return {
        'MAE': mae,
        'MSE': mse,
        'RMSE': rmse,
        'RÂ²': r2,
        'MAPE': mape,
        'Explained_Variance': explained_var,
        'Max_Error': max_error,
        'Correlation': correlation,
        'Bias': bias,
        'Relative_Error_%': relative_error,
        'Mean_True': mean_true,
        'Mean_Pred': mean_pred,
        'Std_True': std_true,
        'Std_Pred': std_pred,
        'N_Samples': len(y_true)
    }


def crear_tabla_metricas(metricas_dict, nombre_modelo="Modelo", mostrar_estadisticas=True):
    """
    Crea una tabla formateada con las mÃ©tricas de un modelo.
    
    Args:
        metricas_dict: Diccionario con mÃ©tricas del modelo
        nombre_modelo: Nombre del modelo para mostrar
        mostrar_estadisticas: Si mostrar estadÃ­sticas descriptivas
    
    Returns:
        pd.DataFrame: Tabla con mÃ©tricas formateadas
    """
    
    # Definir orden y nombres de mÃ©tricas principales
    metricas_principales = [
        ('MAE', 'Mean Absolute Error'),
        ('MSE', 'Mean Squared Error'),
        ('RMSE', 'Root Mean Squared Error'),
        ('RÂ²', 'R-squared'),
        ('MAPE', 'Mean Absolute Percentage Error (%)'),
        ('Explained_Variance', 'Explained Variance'),
        ('Max_Error', 'Maximum Error'),
        ('Correlation', 'Correlation'),
        ('Bias', 'Bias'),
        ('Relative_Error_%', 'Relative Error (%)')
    ]
    
    # Crear DataFrame principal
    data = []
    for key, desc in metricas_principales:
        if key in metricas_dict:
            value = metricas_dict[key]
            # Formatear valores
            if key in ['RÂ²', 'Explained_Variance', 'Correlation']:
                formatted_value = f"{value:.4f}"
            elif key in ['MAPE', 'Relative_Error_%']:
                formatted_value = f"{value:.2f}%"
            elif key in ['MAE', 'MSE', 'RMSE', 'Max_Error', 'Bias']:
                formatted_value = f"{value:.4f}"
            else:
                formatted_value = f"{value:.4f}"
            
            data.append({
                'MÃ©trica': desc,
                nombre_modelo: formatted_value
            })
    
    df_metricas = pd.DataFrame(data)
    
    # Agregar estadÃ­sticas descriptivas si se solicita
    if mostrar_estadisticas:
        estadisticas = [
            ('Mean_True', 'Media Valores Reales'),
            ('Mean_Pred', 'Media Predicciones'),
            ('Std_True', 'Desv. Est. Valores Reales'),
            ('Std_Pred', 'Desv. Est. Predicciones'),
            ('N_Samples', 'NÃºmero de Muestras')
        ]
        
        data_stats = []
        for key, desc in estadisticas:
            if key in metricas_dict:
                value = metricas_dict[key]
                if key == 'N_Samples':
                    formatted_value = f"{int(value):,}"
                else:
                    formatted_value = f"{value:.4f}"
                
                data_stats.append({
                    'MÃ©trica': desc,
                    nombre_modelo: formatted_value
                })
        
        df_stats = pd.DataFrame(data_stats)
        
        # Separador
        separador = pd.DataFrame({
            'MÃ©trica': ['--- EstadÃ­sticas Descriptivas ---'],
            nombre_modelo: ['']
        })
        
        df_metricas = pd.concat([df_metricas, separador, df_stats], ignore_index=True)
    
    return df_metricas


def evaluar_modelo_regresion(y_true, y_pred, nombre_modelo="Modelo", 
                           mostrar_tabla=True, mostrar_estadisticas=True,
                           mostrar_plot=True, analisis_completo=False, figsize=(10, 6)):
    """
    EvalÃºa un modelo de regresiÃ³n y muestra mÃ©tricas en tabla.
    
    Args:
        y_true: Valores reales
        y_pred: Valores predichos
        nombre_modelo: Nombre del modelo
        mostrar_tabla: Si mostrar la tabla de mÃ©tricas
        mostrar_estadisticas: Si incluir estadÃ­sticas descriptivas
        mostrar_plot: Si mostrar grÃ¡fico de predicciones vs reales
        analisis_completo: Si mostrar anÃ¡lisis completo con residuos
        figsize: TamaÃ±o de la figura
    
    Returns:
        tuple: (metricas_dict, df_tabla)
    """
    
    # Calcular mÃ©tricas
    metricas = calcular_metricas_regresion(y_true, y_pred)
    
    # Crear tabla
    df_tabla = crear_tabla_metricas(metricas, nombre_modelo, mostrar_estadisticas)
    
    # Mostrar tabla si se solicita
    if mostrar_tabla:
        print(f"\n{'='*60}")
        print(f"MÃ‰TRICAS DE REGRESIÃ“N - {nombre_modelo}")
        print(f"{'='*60}")
        print(df_tabla.to_string(index=False))
        print(f"{'='*60}")
    
    # Mostrar anÃ¡lisis completo o plot bÃ¡sico
    if analisis_completo:
        grafico_analisis_completo(y_true, y_pred, nombre_modelo, figsize=(15, 10))
    elif mostrar_plot:
        _plot_predicciones_vs_reales(y_true, y_pred, nombre_modelo, figsize)
    
    return metricas, df_tabla


def _plot_predicciones_vs_reales(y_true, y_pred, nombre_modelo, figsize):
    """
    Crea grÃ¡fico de predicciones vs valores reales con mÃ©tricas integradas.
    """
    
    plt.figure(figsize=figsize)
    
    # Convertir a arrays numpy
    y_true = np.array(y_true)
    y_pred = np.array(y_pred)
    
    # Scatter plot con colores segÃºn el error
    errors = np.abs(y_true - y_pred)
    scatter = plt.scatter(y_true, y_pred, c=errors, cmap='viridis', alpha=0.6, s=30, 
                         edgecolors='black', linewidth=0.5, label='Datos')
    
    # Colorbar para los errores
    cbar = plt.colorbar(scatter)
    cbar.set_label('Error Absoluto', rotation=270, labelpad=15)
    
    # LÃ­nea diagonal perfecta
    min_val = min(y_true.min(), y_pred.min())
    max_val = max(y_true.max(), y_pred.max())
    plt.plot([min_val, max_val], [min_val, max_val], 'r--', linewidth=2, 
             label='PredicciÃ³n Perfecta', alpha=0.8)
    
    # LÃ­nea de tendencia
    z = np.polyfit(y_true, y_pred, 1)
    p = np.poly1d(z)
    plt.plot(y_true, p(y_true), 'g-', linewidth=2, alpha=0.8, 
             label=f'Tendencia (pendiente={z[0]:.3f})')
    
    # Calcular mÃ©tricas principales
    r2 = r2_score(y_true, y_pred)
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    mae = mean_absolute_error(y_true, y_pred)
    
    # Agregar texto con mÃ©tricas en el grÃ¡fico
    textstr = f'RÂ² = {r2:.4f}\nRMSE = {rmse:.4f}\nMAE = {mae:.4f}\nN = {len(y_true):,}'
    props = dict(boxstyle='round', facecolor='wheat', alpha=0.8)
    plt.text(0.05, 0.95, textstr, transform=plt.gca().transAxes, fontsize=10,
             verticalalignment='top', bbox=props)
    
    # Formato
    plt.xlabel('Valores Reales', fontsize=12)
    plt.ylabel('Predicciones', fontsize=12)
    plt.title(f'{nombre_modelo} - Predicciones vs Valores Reales', fontsize=14, fontweight='bold')
    plt.legend(loc='lower right')
    plt.grid(True, alpha=0.3)
    
    # Igualar aspectos para que la lÃ­nea diagonal se vea como 45Â°
    plt.axis('equal')
    plt.tight_layout()
    plt.show()


def grafico_analisis_completo(y_true, y_pred, nombre_modelo="Modelo", figsize=(15, 10)):
    """
    Crea un anÃ¡lisis grÃ¡fico completo del modelo con mÃºltiples visualizaciones.
    
    Args:
        y_true: Valores reales
        y_pred: Valores predichos  
        nombre_modelo: Nombre del modelo
        figsize: TamaÃ±o de la figura
    """
    
    # Convertir a arrays numpy
    y_true = np.array(y_true)
    y_pred = np.array(y_pred)
    residuos = y_true - y_pred
    
    # Crear subplots
    fig, axes = plt.subplots(2, 2, figsize=figsize)
    fig.suptitle(f'AnÃ¡lisis Completo del Modelo: {nombre_modelo}', fontsize=16, fontweight='bold')
    
    # 1. Predicciones vs Valores Reales
    ax1 = axes[0, 0]
    errors = np.abs(residuos)
    scatter = ax1.scatter(y_true, y_pred, c=errors, cmap='viridis', alpha=0.6, s=30)
    
    # LÃ­nea diagonal perfecta
    min_val = min(y_true.min(), y_pred.min())
    max_val = max(y_true.max(), y_pred.max())
    ax1.plot([min_val, max_val], [min_val, max_val], 'r--', linewidth=2, alpha=0.8)
    
    # LÃ­nea de tendencia
    z = np.polyfit(y_true, y_pred, 1)
    p = np.poly1d(z)
    ax1.plot(y_true, p(y_true), 'g-', linewidth=2, alpha=0.8)
    
    # MÃ©tricas
    r2 = r2_score(y_true, y_pred)
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    textstr = f'RÂ² = {r2:.4f}\nRMSE = {rmse:.4f}'
    ax1.text(0.05, 0.95, textstr, transform=ax1.transAxes, fontsize=10,
             verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
    
    ax1.set_xlabel('Valores Reales')
    ax1.set_ylabel('Predicciones')
    ax1.set_title('Predicciones vs Valores Reales')
    ax1.grid(True, alpha=0.3)
    
    # 2. Residuos vs Predicciones
    ax2 = axes[0, 1]
    ax2.scatter(y_pred, residuos, alpha=0.6, s=30)
    ax2.axhline(y=0, color='r', linestyle='--', linewidth=2)
    ax2.set_xlabel('Predicciones')
    ax2.set_ylabel('Residuos (Real - Predicho)')
    ax2.set_title('Residuos vs Predicciones')
    ax2.grid(True, alpha=0.3)
    
    # 3. Histograma de Residuos
    ax3 = axes[1, 0]
    ax3.hist(residuos, bins=30, alpha=0.7, color='skyblue', edgecolor='black')
    ax3.axvline(x=0, color='r', linestyle='--', linewidth=2)
    ax3.axvline(x=np.mean(residuos), color='g', linestyle='--', linewidth=2, 
                label=f'Media = {np.mean(residuos):.4f}')
    ax3.set_xlabel('Residuos')
    ax3.set_ylabel('Frecuencia')
    ax3.set_title('DistribuciÃ³n de Residuos')
    ax3.legend()
    ax3.grid(True, alpha=0.3)
    
    # 4. Q-Q Plot (aproximado)
    ax4 = axes[1, 1]
    from scipy import stats
    try:
        stats.probplot(residuos, dist="norm", plot=ax4)
        ax4.set_title('Q-Q Plot (Normalidad de Residuos)')
        ax4.grid(True, alpha=0.3)
    except ImportError:
        # Si scipy no estÃ¡ disponible, hacer un grÃ¡fico alternativo
        sorted_residuos = np.sort(residuos)
        n = len(sorted_residuos)
        theoretical_quantiles = stats.norm.ppf((np.arange(1, n+1) - 0.5) / n)
        ax4.scatter(theoretical_quantiles, sorted_residuos, alpha=0.6)
        ax4.plot(theoretical_quantiles, theoretical_quantiles, 'r--', linewidth=2)
        ax4.set_xlabel('Cuantiles TeÃ³ricos')
        ax4.set_ylabel('Cuantiles de Residuos')
        ax4.set_title('Q-Q Plot (Normalidad de Residuos)')
        ax4.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()


def tabla_metricas_modelos(modelos_predicciones, y_true):
    """
    FunciÃ³n simple que recibe un diccionario con modelos y predicciones 
    y genera una tabla prolija de mÃ©tricas.
    
    Args:
        modelos_predicciones: Dict con {nombre_modelo: predicciones}
        y_true: Valores reales
    
    Returns:
        pd.DataFrame: Tabla prolija con mÃ©tricas de todos los modelos
    """
    
    # Convertir y_true a numpy array
    y_true = np.array(y_true)
    
    # Lista para almacenar resultados
    resultados = []
    
    # Calcular mÃ©tricas para cada modelo
    for nombre_modelo, y_pred in modelos_predicciones.items():
        y_pred = np.array(y_pred)
        
        # Calcular mÃ©tricas principales
        mae = mean_absolute_error(y_true, y_pred)
        rmse = np.sqrt(mean_squared_error(y_true, y_pred))
        r2 = r2_score(y_true, y_pred)
        
        # MAPE con manejo de divisiÃ³n por cero
        try:
            mape = mean_absolute_percentage_error(y_true, y_pred) * 100
        except:
            mask = y_true != 0
            mape = np.mean(np.abs((y_true[mask] - y_pred[mask]) / y_true[mask])) * 100 if np.any(mask) else np.inf
        
        # CorrelaciÃ³n
        correlation = np.corrcoef(y_true, y_pred)[0, 1] if len(y_true) > 1 else np.nan
        
        # Agregar a resultados
        resultados.append({
            'Modelo': nombre_modelo,
            'MAE': round(mae, 4),
            'RMSE': round(rmse, 4),
            'RÂ²': round(r2, 4),
            'MAPE (%)': round(mape, 2),
            'CorrelaciÃ³n': round(correlation, 4),
            'N_Muestras': len(y_true)
        })
    
    # Crear DataFrame
    df = pd.DataFrame(resultados)
    
    # Ordenar por RÂ² de mayor a menor
    df = df.sort_values('RÂ²', ascending=False).reset_index(drop=True)
    
    # Agregar ranking
    df.insert(0, 'Rank', range(1, len(df) + 1))
    
    # # Mostrar tabla prolija
    # print("\n" + "="*80)
    # print("ğŸ“Š TABLA DE MÃ‰TRICAS DE MODELOS")
    # print("="*80)
    # print(df.to_string(index=False, float_format='%.4f'))
    # print("="*80)
    
    # Mostrar mejor modelo
    mejor_modelo = df.iloc[0]
    print(f"\nğŸ† MEJOR MODELO: {mejor_modelo['Modelo']}")
    print(f"   RÂ² = {mejor_modelo['RÂ²']:.4f} | RMSE = {mejor_modelo['RMSE']:.4f} | MAE = {mejor_modelo['MAE']:.4f}")
    
    return df
